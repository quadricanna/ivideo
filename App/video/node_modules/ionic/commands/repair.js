"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("@ionic/cli-framework/utils/format");
const utils_fs_1 = require("@ionic/utils-fs");
const path = require("path");
const color_1 = require("../lib/color");
const command_1 = require("../lib/command");
const errors_1 = require("../lib/errors");
const executor_1 = require("../lib/executor");
class RepairCommand extends command_1.Command {
    async getMetadata() {
        return {
            name: 'repair',
            type: 'project',
            summary: 'Remove and recreate dependencies and generated files',
            description: `
This command may be useful when obscure errors or issues are encountered. It removes and recreates dependencies of your project.

For Cordova apps, it removes and recreates the generated native project and the native dependencies of your project.
`,
        };
    }
    async run(inputs, options, runinfo) {
        if (!this.project) {
            throw new errors_1.FatalException(`Cannot run ${color_1.input('ionic repair')} outside a project directory.`);
        }
        const { pkgManagerArgs } = await Promise.resolve().then(() => require('../lib/utils/npm'));
        const [installer, ...installerArgs] = await pkgManagerArgs(this.env.config.get('npmClient'), { command: 'install' });
        const cordova = this.project.getIntegration('cordova');
        if (this.env.flags.interactive) {
            this.env.log.info(`${color_1.input('ionic repair')} will do the following:\n\n` +
                `- Remove ${color_1.strong('node_modules/')} and ${color_1.strong('package-lock.json')}\n` +
                `- Run ${color_1.input([installer, ...installerArgs].join(' '))} to restore dependencies\n` +
                (cordova && cordova.enabled ?
                    `- Remove ${color_1.strong('platforms/')} and ${color_1.strong('plugins/')}\n` +
                        `- Run ${color_1.input('cordova prepare')} to restore platforms and plugins\n` : ''));
        }
        const confirm = await this.env.prompt({
            type: 'confirm',
            name: 'confirm',
            message: 'Continue?',
            default: false,
        });
        if (!confirm) {
            throw new errors_1.FatalException(`Not running ${color_1.input('ionic repair')}.`);
        }
        this.env.log.nl();
        await this.npmRepair(this.project);
        await this.cordovaRepair(this.project, runinfo);
    }
    async npmRepair(project) {
        const { pkgManagerArgs } = await Promise.resolve().then(() => require('../lib/utils/npm'));
        const [installer, ...installerArgs] = await pkgManagerArgs(this.env.config.get('npmClient'), { command: 'install' });
        const tasks = this.createTaskChain();
        const packageLockFile = path.resolve(project.directory, 'package-lock.json');
        const nodeModulesDir = path.resolve(project.directory, 'node_modules');
        tasks.next(`Removing ${color_1.strong(format_1.prettyPath(packageLockFile))}`);
        await utils_fs_1.unlink(packageLockFile);
        tasks.next(`Removing ${color_1.strong(format_1.prettyPath(nodeModulesDir))}`);
        await utils_fs_1.remove(nodeModulesDir);
        tasks.end();
        await this.env.shell.run(installer, installerArgs, { cwd: project.directory, stdio: 'inherit' });
    }
    async cordovaRepair(project, runinfo) {
        const tasks = this.createTaskChain();
        const cordova = project.getIntegration('cordova');
        if (cordova && cordova.enabled) {
            const platformsDir = path.resolve(cordova.root, 'platforms');
            const pluginsDir = path.resolve(cordova.root, 'plugins');
            tasks.next(`Removing ${color_1.strong(format_1.prettyPath(platformsDir))}`);
            await utils_fs_1.remove(platformsDir);
            tasks.next(`Removing ${color_1.strong(format_1.prettyPath(pluginsDir))}`);
            await utils_fs_1.remove(pluginsDir);
            tasks.end();
            await executor_1.runCommand(runinfo, ['cordova', 'prepare', '--no-build']);
        }
    }
}
exports.RepairCommand = RepairCommand;
